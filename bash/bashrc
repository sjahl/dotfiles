# General Stuff

shopt -s checkwinsize
shopt -s cdspell
shopt -s dotglob
shopt -s histappend

# PS1s
#export PS1="[\u@\h \w]\$ "

#two line prompt

export PS1='[\D{%T}][\u:\[\e[31m\]\W\[\e[m\]]$(__git_ps1 " (%s)")\n\[\e[1;33m\] \$\[\e[0m\] \[\e[m\]'
# my old prompts
#export PS1='\[\e[1m\]\u@\h\[\e[m\] \[\e[1m\]\w \[\e[1;33m\]\$\[\e[m\] '
#export PS1='\[\e[1;31m\]\h\[\e[0m\]:\[\e[1;34m\]\w \[\e[0m\]\[\e[1;31m\]\u\[\e[0m\]\$ '
#export PS1='\[\e[1m\][\u@\h \w]\$\[\e[0m\] \[\e[m\]'
#export PS1='\[\e[1;4m\]\u@\h\[\e[m\] \[\e[1m\]\w\n\$\[\e[m\] '

CLICOLOR=1
PAGER=less
LSCOLORS='ExGxFxdxCxDxDxBxBxExEx'
#export PROMPT_COMMAND="history -a; history -c; history -r; $PROMPT_COMMAND"
#export TERM=xterm-256color
[[ $TMUX = "" ]] && export TERM="xterm-256color"

export WORKON_HOME=~/.virtualenvs
source /usr/local/bin/virtualenvwrapper.sh

HISTCONTROL=ignoredups:ignorespace
HISTIGNORE="&:ls:[bf]g:exit"
HISTORY=5000
HISTTIMEFORMAT="%F %T "
LANG=en_US.utf-8
LANGUAGE=en_US.utf-8
LC_ALL=en_US.utf-8
LC_COLLATE=C
LC_CTYPE=en_US.utf-8
PYTHONIOENCODING=utf-8


# Aliases
alias ll='ls -al'
alias sl='ls'
alias cdd='cd'
alias xs='cd'
alias cim='vim'
alias vi='vim'
alias psc='ps xawf -eo pid,user,cgroup,args'
alias srd='screen -rd'
alias sr='screen -r'
alias xl='i3lock -n -c 333333'
alias vimtab='vim "+set noexpandtab"'
alias gvimtab='gvim "+set noexpandtab"'
alias ta='tmux a'
alias shs='ssh'
alias ri='ri -T'
alias tmux="TERM=screen-256color-bce tmux"
alias ssh-nokerberos='ssh -o GSSAPIAuthentication=no -o GSSAPIKeyExchange=no -o GSSAPIDelegateCredentials=no -o GSSAPITrustDNS=no'
alias password='openssl rand -base64 14'
alias sprunge='curl -F "sprunge=<-" http://sprunge.us'
alias pgrep='pgrep -alf'
alias orch='cd ~/git/quantopian/orchestration && workon orchestration'
alias resea='cd ~/git/quantopian/research_env && workon research_env'
alias cfs="aws cloudformation describe-stacks --query 'Stacks[].StackName'"
alias asgs="aws autoscaling describe-auto-scaling-groups --query 'AutoScalingGroups[].AutoScalingGroupName'"
alias elbs="aws elb describe-load-balancers --query 'LoadBalancerDescriptions[].LoadBalancerName'"
alias deploys="aws ec2 describe-tags --filter \"Name=tag-key,Values=Deployment\" --query 'Tags[].Value' | grep '\"' | sed 's/.*\"\(.*"
alias cg='cd `git rev-parse --show-toplevel`'
alias timevmstat="vmstat -S M 3 | awk '{now=strftime(\"%Y-%m-%d %T \"); print now $0}'"
alias emc='emacsclient -n'
alias flake-py3='pip2 uninstall -y flake8 && pip3 install --upgrade flake8'
alias flake-py2='pip3 uninstall -y flake8 && pip2 install --upgrade flake8'

# only apply certain annoying platform specific stuff on the right platforms.
case ${OSTYPE} in
# Linux returns strings like: linux-gnu, linux
    linux*)
      alias       ls='ls --color=always'
      if [ -f /etc/bash_completion ]; then
          . /etc/bash_completion
      fi
      if [ -d "$HOME/bin" ] ; then
              PATH="$HOME/bin:$HOME/.rbenv/bin:$PATH"
      fi

        ;;

# MacOS X returns strings like: darwin
    darwin*)
    alias ls="ls -GF"
    # Bash completion
    if [ -f `brew --prefix`/etc/bash_completion ]; then
        . `brew --prefix`/etc/bash_completion
    fi
        ;;
esac

complete -C aws_completer aws

export AWS_PROFILE=default
export AWS_DEFAULT_PROFILE=default

# various aws functions
awsenv ()
{
    environment=$1;
    if [[ -z $environment ]]; then
        env | grep --color=auto AWS;
    else
        if [[ $environment == 'clear' ]]; then
            unset AWS_PROFILE;
            unset AWS_DEFAULT_PROFILE;
        else
            export AWS_PROFILE=$environment;
            export AWS_DEFAULT_PROFILE=$environment;
            env | grep --color=auto AWS;
        fi;
    fi
}

iam_keys ()
{
    for u in $(aws iam list-users --query Users[].UserName --output text);
    do
        cmd="aws iam list-access-keys --user-name $u --query 'AccessKeyMetadata[].[UserName,AccessKeyId]' --output text";
        eval $cmd;
    done
}

quantoec2 ()
{
    if [[ -z $1 && -z $2 ]]; then
        echo "Usage: quantoec2 <environment(development|staging|production)> <group/tag(cassandra|elasticsearch|tag_Name_Foo)> [command]";
    else
        if [[ -z $3 ]]; then
            ansible -i ${HOME}/git/quantopian/orchestration/ansible/environments/${1} ${2} --list-hosts;
        else
            ansible -i ${HOME}/git/quantopian/orchestration/ansible/environments/${1} ${2} -m shell -a "${3}";
        fi;
    fi
}

quantotags ()
{
    if [[ -z $1 && -z $2 ]]; then
        echo "Usage: quantotags <environment(Staging|Production)> <deployment(Consul,Databazaar,etc)> [--latest]";
    else
        instances=$(aws ec2 describe-instances --filters "Name=tag:Deployment,Values=$2" "Name=tag:Environment,Values=$1" --query Reservations[].Instances[]);
        if [[ -z $3 ]]; then
            echo "$instances" | jq '.[] | {id: .InstanceId, fqdn: .PublicDnsName, launched: .LaunchTime, az: .Placement.AvailabilityZone, state: .State.Name}';
        else
            if [[ $3 == '--latest' ]]; then
                echo "not done";
            fi;
        fi;
    fi
}

watchec2 ()
{
    if [[ -z $1 ]]; then
        echo "Usage: watchec2 <fqdn>";
    else
        watch -n 3 nc -vz $1 22;
    fi
}

export VAULT_TOKENS_PATH=~/Private/vault/tokens
vault_env ()
{
    environment=$1;
    if [[ -z $environment ]]; then
        if [[ -n $VAULT_ADDR || -n $VAULT_TOKEN ]]; then
            echo $VAULT_ADDR;
            [[ -n $VAULT_TOKEN ]] && echo "VAULT_TOKEN is set.";
        else
            echo "Vault is not configured in your environment";
        fi;
    else
        if [[ $environment == 'clear' ]]; then
            unset VAULT_ADDR;
            unset VAULT_TOKEN;
            echo "unset VAULT_ADDR and VAULT_TOKEN";
        else
            export VAULT_ADDR=https://consul.$environment.int.dynoquant.com:8200;
            VAULT_TOKEN_FILE="${VAULT_TOKENS_PATH}/.vault-token.$environment";
            export VAULT_TOKEN=$(cat ${VAULT_TOKEN_FILE});
            echo "VAULT_ADDR: $VAULT_ADDR";
            echo "VAULT_TOKEN: (see ${VAULT_TOKEN_FILE})";
        fi;
    fi
}

export PATH="$PATH:$HOME/.rvm/bin" # Add RVM to PATH for scripting

function git-etags () {
    if [ "$#" -eq 0 ]
    then
        local ROOT=`git rev-parse --show-toplevel`;
    elif [ "$#" -eq 1 ]
    then
        local ROOT=$1
    else
        echo "Too many args."
        exit 1
    fi
    pushd $ROOT > /dev/null
    {
        git ls-files --full-name;
        git submodule foreach --quiet --recursive \
            'git ls-files --full-name | while read line; do echo "$path/$line"; done;'
    } | xargs etags -o "TAGS"
    popd > /dev/null
}
